---
title: "OculinaDEseq_host"
author: "Hannah Aichelman"
date: "10/21/2019"
output: html_document
---


```{r message=FALSE, warning=FALSE}

library(tidyr)
library(plyr)
library(dplyr)
library(DESeq2)
library(ggplot2)
#library(affycoretools)
#library(arrayQualityMetrics)
library(genefilter)
#library(DESeq)
library(cowplot)
library(readr)
library(RColorBrewer)
library(gplots)
library(knitr)
library(plotly)
library(vegan)
library(kableExtra)
library(reshape2)
library(prettydoc)
library(VennDiagram)
```

Read in Oculina host counts file. 
```{r,cache=TRUE, echo=FALSE}
countDataHost <- read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/CountsFiles/mapping_hannynewref/Oculina_counts_newref_host.txt")
```


Re-name samples with treatment and symbiotic state info
```{r,cache=TRUE}
names(countDataHost) = c("OA4_C_W", "OA5_F_W", "OA6_H_W", 
                        "OC4_F_B",	"OC5_H_B",	"OC9_C_B",	
                        "OD4_C_B",	"OD5_F_B",	"OD6_H_B",
                        "OE10_F_W", "OE11_C_W", "OE3_H_W",
                        "OF7_C_B",	"OF8_F_B",	"OF9_H_B",
                        "OH11_F_W", "OH15_H_W", "OH1_C_W",
                        "OI1_C_B",	"OI2_F_B",	"OI3_H_B",	
                        "OJ13_C_B",	"OJ14_F_B",	"OJ15_H_B",	
                        "OK1_C_W", "OK2_F_W", "OK3_H_W",
                        "OL6_C_B",	"OL7_F_B",	"OL8_H_B",	
                        "OM1_C_B",	"OM2_F_B",	"OM3_H_B",
                        "ON4_C_W", "ON5_F_W", "ON6_H_W",
                        "OO1_C_W", "OO2_F_W",
                        "OP1_C_W", "OP2_F_W", "OP3_H_W",
                        "OQ11_H_W", "OQ1_C_W", "OQ4_F_W",
                        "OR7_C_B",	"OR8_F_B",	"OR9_H_B")

countDataHost_brown = countDataHost %>%
  select(-c("OA4_C_W", "OA5_F_W", "OA6_H_W", "OE10_F_W", "OE11_C_W", "OE3_H_W", "OH11_F_W", "OH15_H_W", "OH1_C_W", "OK1_C_W", "OK2_F_W", "OK3_H_W", "ON4_C_W", "ON5_F_W", "ON6_H_W", "OO1_C_W", "OO2_F_W", "OP1_C_W", "OP2_F_W", "OP3_H_W", "OQ11_H_W", "OQ1_C_W", "OQ4_F_W"))

countDataHost_white = countDataHost %>%
  select(c("OA4_C_W", "OA5_F_W", "OA6_H_W", "OE10_F_W", "OE11_C_W", "OE3_H_W", "OH11_F_W", "OH15_H_W", "OH1_C_W", "OK1_C_W", "OK2_F_W", "OK3_H_W", "ON4_C_W", "ON5_F_W", "ON6_H_W", "OO1_C_W", "OO2_F_W", "OP1_C_W", "OP2_F_W", "OP3_H_W", "OQ11_H_W", "OQ1_C_W", "OQ4_F_W"))
```


Set up experimental design matrix
Based on clone analysis, there are 3 sets of clones in Oculina individuals:
N+O+P -> Z (white)
L+M -> Y (brown)
H+K -> X (white)
Also, OR9_H_B identified as an outlier in original array quality metrics run, so removed. 

Details on github: https://github.com/wuitchik/MPCC_2018/tree/main/Host_analyses/Outlier_detection

```{r,cache=TRUE}
treatmentHost_brown = as.factor(sapply(strsplit(colnames(countDataHost_brown), split = "_"), "[[", 2)) %>%
  revalue(c("C" = "control", "F" = "freezing", "H" = "hot"))

treatmentHost_white = as.factor(sapply(strsplit(colnames(countDataHost_white), split = "_"), "[[", 2)) %>%
  revalue(c("C" = "control", "F" = "freezing", "H" = "hot"))

genotypeHost_brown  = as.factor(sapply(strsplit(colnames(countDataHost_brown), split = ""), "[[", 2))
genotypeHost_white  = as.factor(sapply(strsplit(colnames(countDataHost_white), split = ""), "[[", 2))

expDesign_Host_brown = data.frame(colnames(countDataHost_brown), treatmentHost_brown, genotypeHost_brown)
expDesign_Host_brown$type = "brown_host"
expDesign_Host_brown$treat_type = paste(expDesign_Host_brown$treatmentHost_brown,expDesign_Host_brown$type, sep = "_")
names(expDesign_Host_brown) = c("sample", "treatment", "genotype", "type", "treat_type")

expDesign_Host_white = data.frame(colnames(countDataHost_white), treatmentHost_white, genotypeHost_white)
expDesign_Host_white$type = "white_host"
expDesign_Host_white$treat_type = paste(expDesign_Host_white$treatmentHost_white,expDesign_Host_white$type, sep = "_")
names(expDesign_Host_white) = c("sample", "treatment", "genotype", "type", "treat_type")


#re-name genotypes to indicate clones
# first white hosts
expDesign_Host_white_clones_removed = expDesign_Host_white %>%
  mutate(genotype = recode(genotype, A="A", E="E", H="X", K="X", N="Z", O="Z", P="Z", Q="Q"))

x.genotype = expDesign_Host_white_clones_removed %>%
  filter(genotype == "X") %>%
  group_by(treatment) %>%
  slice_sample(n=1)

z.genotype = expDesign_Host_white_clones_removed %>%
  filter(genotype == "Z") %>%
  group_by(treatment) %>%
  slice_sample(n=2)

excluded.list.white = c(x.genotype$sample, z.genotype$sample)

expDesign_Host_white_clones_removed = expDesign_Host_white_clones_removed %>%
  filter(!sample %in% excluded.list.white)

# now for brown hosts
expDesign_Host_brown_clones_removed = expDesign_Host_brown %>%
  mutate(genotype = recode(genotype, C="C", D="D", F="F", I="I", J="J", L="Y", M="Y", R="R"))

y.genotype = expDesign_Host_brown_clones_removed %>%
  filter(genotype == "Y") %>%
  group_by(greatment) %>%
  slice_sample(n=1)

excluded.list.brown = c(y.genotype$sample)

expDesign_Host_white_clones_removed = expDesign_Host_white_clones_removed %>%
  filter(!sample %in% excluded.list.white)
```

Experimental Design key with sample names 
```{r,cache=TRUE, echo=FALSE}
kable(expDesign_Host_brown) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

kable(expDesign_Host_white) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```
Descriptive Summary stats of the mapped reads. 

```{r echo=FALSE}
stats.per.sample.brown = data.frame(t(do.call(cbind, lapply(countDataHost_brown, summary))))
      stats.per.sample.brown$libsum = apply(countDataHost_brown, 2, sum) ## libsum
      stats.per.sample.brown$perc05 = apply(countDataHost_brown, 2, quantile, 0.05)
      stats.per.sample.brown$perc10 = apply(countDataHost_brown, 2, quantile, 0.10)
      stats.per.sample.brown$perc90 = apply(countDataHost_brown, 2, quantile, 0.90)
      stats.per.sample.brown$perc95 = apply(countDataHost_brown, 2, quantile, 0.95)
      stats.per.sample.brown$zeros = apply(countDataHost_brown==0, 2, sum)
      stats.per.sample.brown$percent.zeros = 100*stats.per.sample.brown$zeros/nrow(countDataHost_brown)
write.csv(stats.per.sample.brown, file= "/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/oculina_brownhost_summary_table.csv", quote = FALSE)

stats.per.sample.white = data.frame(t(do.call(cbind, lapply(countDataHost_white, summary))))
      stats.per.sample.white$libsum = apply(countDataHost_white, 2, sum) ## libsum
      stats.per.sample.white$perc05 = apply(countDataHost_white, 2, quantile, 0.05)
      stats.per.sample.white$perc10 = apply(countDataHost_white, 2, quantile, 0.10)
      stats.per.sample.white$perc90 = apply(countDataHost_white, 2, quantile, 0.90)
      stats.per.sample.white$perc95 = apply(countDataHost_white, 2, quantile, 0.95)
      stats.per.sample.white$zeros = apply(countDataHost_white==0, 2, sum)
      stats.per.sample.white$percent.zeros = 100*stats.per.sample.white$zeros/nrow(countDataHost_white)
write.csv(stats.per.sample.white, file= "/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/oculina_whitehost_summary_table.csv", quote = FALSE)
      
kable(stats.per.sample.brown) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

kable(stats.per.sample.white) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

```

#Outlier Detection


Conduct array quality metrics to identify outliers  

```{r, cache=TRUE}
real=newCountDataSet(countDataHost,expDesign) 
real=estimateSizeFactors(real)
```

```{r, fig.align='center', cache=TRUE }
plot(sort(sizeFactors(real)), main = "Ocuina Host Size Factors") 
```
<br>
Size factors of each sample used to normalize between libraries. 
<br> 
<br> 
Create a directory with a bunch of output figures from arrayQualityMetrics() for you to explore if their are outliers. 

```{r message=FALSE, warning=FALSE, eval = FALSE}
cds=estimateDispersions(real,method="blind")
vsdBlind=varianceStabilizingTransformation(cds)
arrayQualityMetrics(vsdBlind,intgroup=c("treatment"), force=TRUE, outdir = "Oculina_brown_host_arrayqualitymetrics") # this makes a directory "arrayQualityMetrics" and outputs various reports on outliers
```

Look at total counts across Oculina host and symbiont samples
```{r}
totalCountshost=colSums(countDataHost)
totalCountshost
barplot(totalCountshost, col=treatment, ylab="raw counts", main = "Oculina host total counts")

min(totalCountshost) 
max(totalCountshost) 


totalCountssym=colSums(countDataSym)
totalCountssym
barplot(totalCountssym, col=treatment, ylab="raw counts", main = "Oculina symbiont total counts")

min(totalCountssym) 
max(totalCountssym) 

```
####Outlier Conclusisons

Do not need to remove any outliers for the Oculina host or symbiont. This is considering brown/symbiotic individuals only though.


***

#Differential Expression

***

```{r warning=FALSE, cache=TRUE}
dds.brown<-DESeqDataSetFromMatrix(countData=countDataHost_brown, colData=expDesign_Host_brown, design=~genotype + treatment) #can only test for the main effects of treatment
dds.brown = DESeq(dds.brown)
results.brown = results(dds.brown)
summary(results.brown)

dds.white<-DESeqDataSetFromMatrix(countData=countDataHost_white, colData=expDesign_Host_white, design=~genotype + treatment) #can only test for the main effects of treatment
dds.white = DESeq(dds.white)
results.white = results(dds.white)
summary(results.white)
```



Let's check to see if we set up our contrast correctly. We should have the treatment condition first and the control second in the log2 fold change (MLE) output. 

```{r, cache=TRUE}
head(results.brown)
head(results.white)
```

```{r echo=FALSE, cache=TRUE}
norm.counts.brownhost = counts(dds.brown, normalized = TRUE) # these are the counts DESeq uses
write.csv(norm.counts.brownhost, "/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/Oculina_normalized_counts_brownhost.csv") #these are all counts, not considering treatment comparisons

norm.counts.whitehost = counts(dds.white, normalized = TRUE) # these are the counts DESeq uses
write.csv(norm.counts.whitehost, "/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/Oculina_normalized_counts_whitehost.csv") #these are all counts, not considering treatment comparisons
              
norm.counts.brown.stats = data.frame(
  min = apply(norm.counts.brownhost, 2, min),
  mean = apply(norm.counts.brownhost, 2, mean),
  median = apply(norm.counts.brownhost, 2, median), 
  max = apply(norm.counts.brownhost, 2, max),
  zeros = apply(norm.counts.brownhost == 0, 2, sum), 
  percent.zeros = 100* apply(norm.counts.brownhost == 0, 2, sum) / nrow(norm.counts.brownhost) 
)

norm.counts.white.stats = data.frame(
  min = apply(norm.counts.whitehost, 2, min),
  mean = apply(norm.counts.whitehost, 2, mean),
  median = apply(norm.counts.whitehost, 2, median), 
  max = apply(norm.counts.whitehost, 2, max),
  zeros = apply(norm.counts.whitehost == 0, 2, sum), 
  percent.zeros = 100* apply(norm.counts.whitehost == 0, 2, sum) / nrow(norm.counts.whitehost) 
)

kable(norm.counts.brown.stats) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
kable(norm.counts.white.stats) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

Lets do a rlogged transformation, which is useful various unsupervised clustering analyses. Be sure the include blind = TRUE as it doesn't normalize the data with any priors from our experimental design. 

```{r, cache=TRUE}
rlogged.brown = rlogTransformation(dds.brown, blind = TRUE)
rlogged.white = rlogTransformation(dds.white, blind = TRUE)
```

Hot versus control expression comparison
```{r}
##second term is the "control"
res_hot_brown_host <- results(dds.brown, contrast=c("treatment","hot","control"))
head(res_hot_brown_host)
#how many FDR < 10%?
table(res_hot_brown_host$padj<0.05)
# 0.1=750
# 0.05=511
# 0.01=253
summary(res_hot_brown_host)
write.table(res_hot_brown_host, file="/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/oculina_hot_brown_host_results.txt", quote=F, sep="\t")

res_hot_white_host <- results(dds.white, contrast=c("treatment","hot","control"))
head(res_hot_white_host)
#how many FDR < 10%?
table(res_hot_white_host$padj<0.1)
# 0.1=363
# 0.05=240
# 0.01=98
summary(res_hot_white_host)
write.table(res_hot_white_host, file="/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/oculina_hot_white_host_results.txt", quote=F, sep="\t")
```

MA plot, red dots indicate genes significantly differentially expressed at FDR < 0.1 

```{r, cache=TRUE, fig.align='center'}
DESeq2::plotMA(res_hot_brown_host, main = "Hot vs Control, Brown Host")
DESeq2::plotMA(res_hot_white_host, main = "Hot vs Control, White Host")
```


Cold versus control expression comparison
```{r}
##second term is the "control"
res_cold_brown_host <- results(dds.brown, contrast=c("treatment","freezing","control"))
head(res_cold_brown_host)
#how many FDR < 10%?
table(res_cold_brown_host$padj<0.01)
# 0.1=4958
# 0.05=4077
# 0.01=2829
summary(res_cold_brown_host)
write.table(res_cold_brown_host, file="/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/oculina_cold_brown_host_results.txt", quote=F, sep="\t")

res_cold_white_host <- results(dds.white, contrast=c("treatment","freezing","control"))
head(res_cold_white_host)
#how many FDR < 10%?
table(res_cold_white_host$padj<0.01)
# 0.1=3830
# 0.05=3041
# 0.01=1061
summary(res_cold_white_host)
write.table(res_cold_white_host, file="/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/oculina_cold_white_host_results.txt", quote=F, sep="\t")

```

MA plot, red dots indicate genes significantly differentially expressed at FDR < 0.1 

```{r, cache=TRUE, fig.align='center'}
DESeq2::plotMA(res_cold_brown_host, main = "Freezing vs Control, Brown Host")
DESeq2::plotMA(res_cold_white_host, main = "Freezing vs Control, White Host")
```


##Heatmaps
***
<br> <br> 

Overall expression, sample by distance. 

```{r, cache=TRUE, fig.align="center"}
sampleDists.brown <- as.matrix(dist(t(assay(rlogged.brown))))
heatmap.2(as.matrix(sampleDists.brown), key=F, trace="none",
          col=colorpanel(100, "black", "white"),
          margin=c(10, 10))

sampleDists.white <- as.matrix(dist(t(assay(rlogged.white))))
heatmap.2(as.matrix(sampleDists.white), key=F, trace="none",
          col=colorpanel(100, "black", "white"),
          margin=c(10, 10))
```

<br><br>
<b>Individual genes heatmap </b> 
<br> 
Now plotting the z scores, as heatmap2 creates nice clean clusters by doing this. Upregulation indicated by warmer colors, downregulation indicated by cooler colors.

First for heat vs. control comparison
```{r, cache=TRUE, fig.align='center'}
norm_counts_brown = read.csv("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/Oculina_normalized_counts_brownhost.csv")
hm_brown = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/oculina_hot_brown_host_results.txt", header=TRUE, col.names=c("X", "baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue","padj")) %>% as_tibble() %>%
  filter(padj < 0.1) %>% # only want the most DEGs
  select(X) %>%
  merge(norm_counts_brown, by.x = "X", by.y = "X")  # turn into a countdatafile
  row.names(hm_brown) = hm_brown$X
  hm_brown$X = NULL

## Turning into z-score table
hm_brown.z = data.matrix(hm_brown)
hm_brown.z = sweep(hm_brown.z, 1L, rowMeans(hm_brown.z), check.margin = FALSE)
hm_brown.z.sx = apply(hm_brown.z, 1L, sd)
hm_brown.z = sweep(hm_brown.z, 1L, hm_brown.z.sx, "/", check.margin = FALSE)
hm_brown.z = data.matrix(hm_brown.z)

colour = colorRampPalette(rev(c("chocolate1","#FEE090","grey10", "cyan3","cyan")))(100)
heatmap.2(hm_brown.z, col = colour, Rowv = TRUE, Colv = TRUE, scale = "row", 
          dendrogram = "both",
          trace = "none", 
          margin = c(5,15))


norm_counts_white = read.csv("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/Oculina_normalized_counts_whitehost.csv")
hm_white = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/oculina_hot_white_host_results.txt", header=TRUE, col.names=c("X", "baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue","padj")) %>% as_tibble() %>%
  filter(padj < 0.1) %>% # only want the most DEGs
  select(X) %>%
  merge(norm_counts_white, by.x = "X", by.y = "X")  # turn into a countdatafile
  row.names(hm_white) = hm_white$X
  hm_white$X = NULL

## Turning into z-score table
hm_white.z = data.matrix(hm_white)
hm_white.z = sweep(hm_white.z, 1L, rowMeans(hm_white.z), check.margin = FALSE)
hm_white.z.sx = apply(hm_white.z, 1L, sd)
hm_white.z = sweep(hm_white.z, 1L, hm_white.z.sx, "/", check.margin = FALSE)
hm_white.z = data.matrix(hm_white.z)

heatmap.2(hm_white.z, col = colour, Rowv = TRUE, Colv = TRUE, scale = "row", 
          dendrogram = "both",
          trace = "none", 
          margin = c(5,15))

```

Now for cold vs. control comparison
```{r, cache=TRUE, fig.align='center'}
norm_counts_brown = read.csv("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/Oculina_normalized_counts_brownhost.csv")
hm_brown = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/oculina_cold_brown_host_results.txt", header=TRUE, col.names=c("X", "baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue","padj")) %>% as_tibble() %>%
  filter(padj < 0.1) %>% # only want the most DEGs
  select(X) %>%
  merge(norm_counts_brown, by.x = "X", by.y = "X")  # turn into a countdatafile
  row.names(hm_brown) = hm_brown$X
  hm_brown$X = NULL

## Turning into z-score table
hm_brown.z = data.matrix(hm_brown)
hm_brown.z = sweep(hm_brown.z, 1L, rowMeans(hm_brown.z), check.margin = FALSE)
hm_brown.z.sx = apply(hm_brown.z, 1L, sd)
hm_brown.z = sweep(hm_brown.z, 1L, hm_brown.z.sx, "/", check.margin = FALSE)
hm_brown.z = data.matrix(hm_brown.z)

colour = colorRampPalette(rev(c("chocolate1","#FEE090","grey10", "cyan3","cyan")))(100)
heatmap.2(hm_brown.z, col = colour, Rowv = TRUE, Colv = TRUE, scale = "row", 
          dendrogram = "both",
          trace = "none", 
          margin = c(5,15))


norm_counts_white = read.csv("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/Oculina_normalized_counts_whitehost.csv")
hm_white = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/oculina_cold_white_host_results.txt", header=TRUE, col.names=c("X", "baseMean", "log2FoldChange", "lfcSE", "stat", "pvalue","padj")) %>% as_tibble() %>%
  filter(padj < 0.1) %>% # only want the most DEGs
  select(X) %>%
  merge(norm_counts_white, by.x = "X", by.y = "X")  # turn into a countdatafile
  row.names(hm_white) = hm_white$X
  hm_white$X = NULL

## Turning into z-score table
hm_white.z = data.matrix(hm_white)
hm_white.z = sweep(hm_white.z, 1L, rowMeans(hm_white.z), check.margin = FALSE)
hm_white.z.sx = apply(hm_white.z, 1L, sd)
hm_white.z = sweep(hm_white.z, 1L, hm_white.z.sx, "/", check.margin = FALSE)
hm_white.z = data.matrix(hm_white.z)

heatmap.2(hm_white.z, col = colour, Rowv = TRUE, Colv = TRUE, scale = "row", 
          dendrogram = "both",
          trace = "none", 
          margin = c(5,15))
```
##Principal Component Analyses 

<br>
First we create a PCA data frame and calculate the variance estimated by PC1 and PC2
```{r cache=TRUE, fig.align="center"}
pcadata.brown = DESeq2::plotPCA(rlogged.brown, intgroup = c( "treatment", "genotype"), returnData = TRUE)
percentVar.brown = round(100 * attr(pcadata.brown, "percentVar"))
pca.brown = prcomp(t(assay(rlogged.brown)), center = TRUE, scale. = FALSE)

pcadata.white = DESeq2::plotPCA(rlogged.white, intgroup = c( "treatment", "genotype"), returnData = TRUE)
percentVar.white = round(100 * attr(pcadata.white, "percentVar"))
pca.white = prcomp(t(assay(rlogged.white)), center = TRUE, scale. = FALSE)
```
<br><br>

Using adonis from library(vegan) we can see if there are any significant differences based on treatment (as is illustrated in the model displayed below) 
```{r cache=TRUE}
adonis(pca.brown$x ~ genotype + treatment, data = pcadata.brown, method = 'eu')

adonis(pca.white$x ~ genotype + treatment, data = pcadata.white, method = 'eu')
```
<br><br>

```{r cache=TRUE, fig.align="center"}
cols = c("control" = "grey", "freezing" = "#68a2ff", "hot" = "#ea6227")

pca_brown = DESeq2::plotPCA(rlogged.brown, returnData = TRUE, intgroup = c("treatment", "genotype") ) %>% 
      ggplot(aes(x = PC1, y = PC2)) +
      geom_point(aes(colour = treatment), size = 3, shape = 19) +
      scale_colour_manual(values = cols,
                          name = "Treatment") +
      stat_ellipse(aes(color=rlogged.brown$treatment), type = "t", linetype = 2, lwd = 1) +
      xlab(paste0("PC1: ",percentVar.brown[1],"% variance")) +
      ylab(paste0("PC2: ",percentVar.brown[2],"% variance")) +
      #labs(title = "~ treatment, p<0.001")+
      theme_bw()
pca_brown
ggsave(pca_brown, file = "/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/Oculina_plots/brown_host_pca.pdf", width=5, height=4, units=c("in"), useDingbats=FALSE)

pca_white = DESeq2::plotPCA(rlogged.white, returnData = TRUE, intgroup = c("treatment", "genotype") ) %>% 
      ggplot(aes(x = PC1, y = PC2)) +
      geom_point(aes(colour = treatment), size = 3, shape = 19) +
      scale_colour_manual(values = cols,
                          name = "Treatment") +
      stat_ellipse(aes(color=rlogged.white$treatment), type = "t", lwd = 1) +
      xlab(paste0("PC1: ",percentVar.white[1],"% variance")) +
      ylab(paste0("PC2: ",percentVar.white[2],"% variance")) +
      #labs(title = "~ treatment, p<0.001")+
      theme_bw()
pca_white
ggsave(pca_sym, file = "/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/Oculina_plots/white_host_pca.pdf", width=5, height=4, units=c("in"), useDingbats=FALSE)

```
Principal component analyses highlighting treatment groups. Treatment has a significant affect (p < 0.001) on overall expression

<br><br>

```{r cache=TRUE, fig.align="center"}
DESeq2::plotPCA(rlogged, returnData = TRUE, intgroup = c("treatment", "genotype") ) %>% 
      ggplot(aes(x = PC1, y = PC2)) +
      geom_point(aes(colour = genotype), size = 3) +
      xlab(paste0("PC1: ",percentVar[1],"% variance")) +
      ylab(paste0("PC2: ",percentVar[2],"% variance")) +
      labs(title = "~ genotype, p<0.001")+
      theme_cowplot()
```
Principal component analyses highlighting genotypes of coral. Treatment has a significant affect (p < 0.001) on overall expression


##Venn Diagrams

Read in our result tables and isolate gene lists that significant in each experiment. 

```{r cache=TRUE}
hot.brown = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/oculina_hot_brown_host_results.txt")
hot.brown = row.names(hot.brown[hot.brown$padj<0.05 & !is.na(hot.brown$padj),])

freezing.brown = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/oculina_cold_brown_host_results.txt")
freezing.brown = row.names(freezing.brown[freezing.brown$padj<0.05 & !is.na(freezing.brown$padj),])

hot.white = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/oculina_hot_white_host_results.txt")
hot.white = row.names(hot.white[hot.white$padj<0.05 & !is.na(hot.white$padj),])

freezing.white = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/deseq/Oculina/tables/oculina_cold_white_host_results.txt")
freezing.white = row.names(freezing.white[freezing.white$padj<0.05 & !is.na(freezing.white$padj),])
```
<br><br>

Set up a venn diagram looking for similar genes in each experiment. 
```{r cache=TRUE}
all_shared.brown = list("Hot" = hot.brown, "Freezing" = freezing.brown)
prettyvenn.brown=venn.diagram(
      x = all_shared.brown,
      filename=NULL,
      col = "transparent",
      fill = c("#ea6227", "#68a2ff"),
      alpha = 0.5,
      #label.col = c("darkred", "white", "darkgreen", "white", "white", "white", "blue4"),
      cex = 2.5,
      fontfamily = "sans",
      fontface = "bold",
      cat.default.pos = "text",
      cat.col = "black",
      cat.cex = 2.5,
      cat.fontfamily = "sans",
      cat.dist = c(0.08, 0.08),
      cat.pos = 1
    );
grid.draw(prettyvenn.brown)
    
all_shared.white = list("Hot" = hot.white, "Freezing" = freezing.white)
prettyvenn.white=venn.diagram(
      x = all_shared.white,
      filename=NULL,
      #col = "transparent",
      fill = c("#ea6227", "#68a2ff"),
      #alpha = 0.5,
      # label.col = c("darkred", "white", "darkgreen", "white", "white", "white", "blue4"),
      cex = 2.5,
      fontfamily = "sans",
      fontface = "bold",
      cat.default.pos = "text",
      cat.col = "black",
      cat.cex = 2.5,
      cat.fontfamily = "sans",
      cat.dist = c(0.08, 0.08),
      cat.pos = 1
    );
grid.draw(prettyvenn.white)

```



##Gene Ontology
Make Gene Ontology input table for MWU for hot treatment
```{r message=FALSE, warning=FALSE, eval = FALSE}
oc_hot_res = read.table("tables/oculina_hot_results.txt")
head(oc_hot_res)
oc_hot_res$isogroup=row.names(oc_hot_res)

go_input_hot_oculina = oc_hot_res %>%
  mutate(mutated_p = -log(pvalue)) %>%
  mutate(mutated_p_updown = ifelse(log2FoldChange < 0, mutated_p*-1, mutated_p*1)) %>%
  select(isogroup, mutated_p_updown) %>%
  na.omit()

nrow(go_input_hot_oculina)
head(go_input_hot_oculina)
colnames(go_input_hot_oculina) <- c("gene", "pval")
head(go_input_hot_oculina)
write.csv(go_input_hot_oculina, file="tables/hot_oculina_host_GO.csv", quote=F, row.names=FALSE)

```

Make Gene Ontology input table for MWU for Oculina cold treatment
```{r message=FALSE, warning=FALSE, eval = FALSE}
oc_cold_res = read.table("tables/oculina_cold_results.txt")
head(oc_cold_res)
oc_cold_res$isogroup=row.names(oc_cold_res)

go_input_cold_oculina = oc_cold_res %>%
  mutate(mutated_p = -log(pvalue)) %>%
  mutate(mutated_p_updown = ifelse(log2FoldChange < 0, mutated_p*-1, mutated_p*1)) %>%
  select(isogroup, mutated_p_updown) %>%
  na.omit()

nrow(go_input_cold_oculina)
head(go_input_cold_oculina)
colnames(go_input_cold_oculina) <- c("gene", "pval")
head(go_input_cold_oculina)
write.csv(go_input_cold_oculina, file="tables/cold_oculina_host_GO.csv", quote=F, row.names=FALSE)
```


### Cellular Components
Hot vs. control comparison first
```{r, cache=TRUE, eval = FALSE}
input="hot_oculina_host_GO.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="Oculina_arbuscula_iso2go.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="CC" # either MF, or BP, or CC
source("gomwu.functions.R")
```

```{r cache=TRUE, eval = FALSE}
gomwuStats(input, goDatabase, goAnnotations, goDivision,
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
	smallest=5,   # a GO category should contain at least this many genes to be considered
	clusterCutHeight=0.25) # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 

# do not continue if the printout shows that no GO terms pass 10% FDR.

```

```{r cache=TRUE, fig.align='center', out.width="900px", eval = FALSE}
pdf("cc_oculina_hot_results.pdf")
cc_oculina_hot_results=gomwuPlot(input,goAnnotations,goDivision,
#	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
	absValue=1,
	level1=0.001, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
	level2=0.0001, # FDR cutoff to print in regular (not italic) font.
	level3=0.00001, # FDR cutoff to print in large bold font.
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
	treeHeight=0.5, # height of the hierarchical clustering tree
  colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
)
dev.off()
write.csv(cc_oculina_hot_results, "cc_oculina_hot.csv")
```


### Molecular Functions

```{r cache=TRUE, eval = FALSE}
goDivision="MF" 
```

```{r cache=TRUE, eval = FALSE}
gomwuStats(input, goDatabase, goAnnotations, goDivision,
	perlPath="perl", 
	largest=0.1, 
	smallest=5,   
	clusterCutHeight=0.25 
)
```

```{r cache=TRUE, fig.align='center', out.width="900px", eval = FALSE}

pdf("mf_oculina_hot_results.pdf")
mf_oculina_hot_results=gomwuPlot(input,goAnnotations,goDivision,
	absValue=1,
	level1=0.001, 
	level2=0.0001, 
	level3=0.00001, 
	txtsize=1.2,    
	treeHeight=0.5, 
  colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") 
)
dev.off()
write.csv(mf_oculina_hot_results, "mf_oculina_hot.csv")
```

### Biological process
```{r cache=TRUE, eval = FALSE}
goDivision="BP"
```

```{r cache=TRUE, eval = FALSE}
gomwuStats(input, goDatabase, goAnnotations, goDivision,
	perlPath="perl", 
	largest=0.1,  
	smallest=5,   
	clusterCutHeight=0.4 
)
```

```{r cache=TRUE, fig.align='center', out.width="900px", eval = FALSE}
pdf("bp_oculina_hot_results.pdf")
bp_oculina_hot_results=gomwuPlot(input,goAnnotations,goDivision,
	absValue=1,
	level1=0.00001, 
	level2=0.000001, 
	level3=0.0000001, 
	txtsize=1.2,    
	treeHeight=0.5, 
  colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") 
)
dev.off()
write.csv(bp_oculina_hot_results, "bp_oculina_hot.csv")
```


Now cold vs. control comparison 
```{r, cache=TRUE, eval = FALSE}
input="cold_oculina_host_GO.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="Oculina_arbuscula_iso2go.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="CC" # either MF, or BP, or CC
source("gomwu.functions.R")
```

```{r cache=TRUE, eval = FALSE}
gomwuStats(input, goDatabase, goAnnotations, goDivision,
	perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
	largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
	smallest=5,   # a GO category should contain at least this many genes to be considered
	clusterCutHeight=0.25) # threshold for merging similar (gene-sharing) terms. See README for details.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead. 
#	Module=TRUE,Alternative="g" # un-remark this if you are analyzing a SIGNED WGCNA module (values: 0 for not in module genes, kME for in-module genes). In the call to gomwuPlot below, specify absValue=0.001 (count number of "good genes" that fall into the module)
#	Module=TRUE # un-remark this if you are analyzing an UNSIGNED WGCNA module 

# do not continue if the printout shows that no GO terms pass 10% FDR.

```

```{r cache=TRUE, fig.align='center', out.width="900px", eval = FALSE}
pdf("cc_oculina_cold_results.pdf")
cc_oculina_cold_results=gomwuPlot(input,goAnnotations,goDivision,
#	absValue=-log(0.05,10),  # genes with the measure value exceeding this will be counted as "good genes". Specify absValue=0.001 if you are doing Fisher's exact test for standard GO enrichment or analyzing a WGCNA module (all non-zero genes = "good genes").
	absValue=1,
	level1=0.00001, # FDR threshold for plotting. Specify level1=1 to plot all GO categories containing genes exceeding the absValue.
	level2=0.000001, # FDR cutoff to print in regular (not italic) font.
	level3=0.0000001, # FDR cutoff to print in large bold font.
	txtsize=1.2,    # decrease to fit more on one page, or increase (after rescaling the plot so the tree fits the text) for better "word cloud" effect
	treeHeight=0.5, # height of the hierarchical clustering tree
  colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") # these are default colors, un-remar and change if needed
)
dev.off()
write.csv(cc_oculina_cold_results, "cc_oculina_cold.csv")
```

### Molecular Functions

```{r cache=TRUE, eval = FALSE}
goDivision="MF" 
```

```{r cache=TRUE, eval = FALSE}
gomwuStats(input, goDatabase, goAnnotations, goDivision,
	perlPath="perl", 
	largest=0.1, 
	smallest=5,   
	clusterCutHeight=0.25 
)
```

```{r cache=TRUE, fig.align='center', out.width="900px", eval = FALSE}
pdf("mf_oculina_cold_results.pdf")
mf_oculina_cold_results=gomwuPlot(input,goAnnotations,goDivision,
	absValue=1,
	level1=0.001, 
	level2=0.0001, 
	level3=0.00001, 
	txtsize=1.2,    
	treeHeight=0.5, 
  colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") 
)
dev.off()
write.csv(mf_oculina_cold_results, "mf_oculina_cold.csv")
```

### Biological process
```{r cache=TRUE, eval = FALSE}
goDivision="BP"
```

```{r cache=TRUE, eval = FALSE}
gomwuStats(input, goDatabase, goAnnotations, goDivision,
	perlPath="perl", 
	largest=0.1,  
	smallest=5,   
	clusterCutHeight=0.4 
)
```

```{r cache=TRUE, fig.align='center', out.width="900px", eval = FALSE}
pdf("bp_oculina_cold_results.pdf")
bp_oculina_cold_results=gomwuPlot(input,goAnnotations,goDivision,
	absValue=1,
	level1=0.00001, 
	level2=0.000001, 
	level3=0.0000001, 
	txtsize=1.2,    
	treeHeight=0.5, 
  colors=c("dodgerblue2","firebrick1","skyblue2","lightcoral") 
)
dev.off()
write.csv(bp_oculina_cold_results, "bp_oculina_cold.csv")
```

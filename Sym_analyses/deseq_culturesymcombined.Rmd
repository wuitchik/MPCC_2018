---
title: "Breviolum Symbiont Combined deseq Analylses"
author: "Hannah Aichelman"
date: "12/2/2022"
output: 
  html_document:
    toc: true
    theme: united
---

### Install and libray packages
```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# This code is from Colleen, lets us library the old version of DESeq (to do array quality metrics) even running versions of R after 3.6

## get Bioconductor packages
if (!requireNamespace("BiocManager"))
install.packages("BiocManager")
BiocManager::install("DESeq2")

## installing WGCNA:
#source("http://bioconductor.org/biocLite.R")
BiocManager::install(c("AnnotationDbi", "impute", "GO.db", "preprocessCore"))
BiocManager::install("WGCNA", dependencies=TRUE)
BiocManager::install("arrayQualityMetrics", dependencies=TRUE) # use this arrayQualityMetrics install if using later versions of R (3.6.3 works)
#repos="http://cran.us.r-project.org"
## R version 3.6 is funky with arrayQualityMetrics and DESeq so need this work around:
install.packages("ape", lib = "/Library/Frameworks/R.framework/Versions/4.0/Resources/library")
library(ape, lib.loc = "/Library/Frameworks/R.framework/Versions/4.0/Resources/library")
install.packages("magick", lib = "/Library/Frameworks/R.framework/Versions/4.0/Resources/library", dependencies = FALSE)
library(magick, lib.loc = "/Library/Frameworks/R.framework/Versions/4.0/Resources/library")
BiocManager::install("arrayQualityMetrics", type = "source", checkBuilt = TRUE, lib.loc = "/Library/Frameworks/R.framework/Versions/4.0/Resources/library")
BiocManager::install("DESeq", type = "source", checkBuilt = TRUE, lib.loc = "/Library/Frameworks/R.framework/Versions/4.0/Resources/library")
```

```{r message=FALSE, warning=FALSE}
library(arrayQualityMetrics)
#library(DESeq)
library(DESeq2)
library(WGCNA)

library(sva) # batch effects
library(tidyr)
library(plyr)
library(dplyr)
library(ggplot2)
library(genefilter)
library(cowplot)
library(readr)
library(RColorBrewer)
library(gplots)
library(knitr)
library(plotly)
library(vegan)
library(kableExtra)
library(reshape2)
library(prettydoc)
library(VennDiagram)
library(tidyverse)
library(gridExtra)
library(adegenet)
```

### Read in and format data

Read in Oculina symbiont counts files, separately for in host and in culture data.  
```{r,cache=TRUE, echo=FALSE}
countDataSym <- read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/CountsFiles/Oculina_Counts_newref_sym.txt")

countDataCulture <- read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/CountsFiles/B_psygmophilum_counts.txt")
```

Read in counts files in a way so that we can merge them, as we don't want the contig names to be rows here, but a column that we can merge on.
```{r,cache=TRUE, echo=FALSE}
countDataSym_tomerge <- read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/CountsFiles/Oculina_Counts_newref_sym.txt", row.names = NULL)
colnames(countDataSym_tomerge)[1] = "contig"

countDataCulture_tomerge <- read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/CountsFiles/B_psygmophilum_counts.txt", row.names = NULL)
colnames(countDataCulture_tomerge)[1] = "contig"

# create a combined counts file for the symbionts in hospite and in culture
countDataCombined = merge(countDataSym_tomerge, countDataCulture_tomerge, by = "contig", all = TRUE)

# replace NA's with 0's and convert contig back to rownames
countDataCombined = countDataCombined %>%
  mutate_all(~replace(., is.na(.), 0)) %>%
  column_to_rownames(var = "contig")

```


Set up experimental design matrix
```{r,cache=TRUE}
# rename columns for individual culture and in hospite data frames
names(countDataSym) = c("OA4", "OA5", "OA6", 
                        "OC4_F_B",	"OC5_H_B",	"OC9_C_B",	
                        "OD4_C_B",	"OD5_F_B",	"OD6_H_B",
                        "OE10", "OE11", "OE3",
                        "OF7_C_B",	"OF8_F_B",	"OF9_H_B",
                        "OH11", "OH15", "OH1",
                        "OI1_C_B",	"OI2_F_B",	"OI3_H_B",	
                        "OJ13_C_B",	"OJ14_F_B",	"OJ15_H_B",	
                        "OK1", "OK2", "OK3",
                        "OL6_C_B",	"OL7_F_B",	"OL8_H_B",	
                        "OM1_C_B",	"OM2_F_B",	"OM3_H_B",
                        "ON4", "ON5", "ON6",
                        "OO1", "OO2",
                        "OP1", "OP2", "OP3",
                        "OQ11", "OQ1", "OQ4",
                        "OR7_C_B",	"OR8_F_B",	"OR9_H_B")

names(countDataCulture) = c("Control_1.1", "Control_1", "Control_2.1", "Control_2", "Control_3.1", "Control_3", "Control_4.1", "Control_4", 
                        "Cool_1", "Cool_2", "Cool_3", "Cool_4",
                        "Heat_1.1", "Heat_1", "Heat_2.1", "Heat_2", "Heat_3.1", "Heat_3", "Heat_4.1", "Heat_4")

# rename columns for combined data frame
names(countDataCombined) = c("OA4", "OA5", "OA6", 
                        "OC4_F_B",	"OC5_H_B",	"OC9_C_B",	
                        "OD4_C_B",	"OD5_F_B",	"OD6_H_B",
                        "OE10", "OE11", "OE3",
                        "OF7_C_B",	"OF8_F_B",	"OF9_H_B",
                        "OH11", "OH15", "OH1",
                        "OI1_C_B",	"OI2_F_B",	"OI3_H_B",	
                        "OJ13_C_B",	"OJ14_F_B",	"OJ15_H_B",	
                        "OK1", "OK2", "OK3",
                        "OL6_C_B",	"OL7_F_B",	"OL8_H_B",	
                        "OM1_C_B",	"OM2_F_B",	"OM3_H_B",
                        "ON4", "ON5", "ON6",
                        "OO1", "OO2",
                        "OP1", "OP2", "OP3",
                        "OQ11", "OQ1", "OQ4",
                        "OR7_C_B",	"OR8_F_B",	"OR9_H_B",
                        "Control_1.1", "Control_1", "Control_2.1", "Control_2", "Control_3.1", "Control_3", "Control_4.1", "Control_4", 
                        "Cool_1", "Cool_2", "Cool_3", "Cool_4",
                        "Heat_1.1", "Heat_1", "Heat_2.1", "Heat_2", "Heat_3.1", "Heat_3", "Heat_4.1", "Heat_4")

# remove aposymbiotic individual columns from the data
countDataSym_brown = countDataSym %>%
  select(-c(OA4, OA5, OA6, OE10, OE11, OE3, OH11, OH15, OH1, OK1, OK2, OK3, ON4, ON5, ON6, OO1, OO2, OP1, OP2, OP3, OQ11, OQ1, OQ4))

countDataCombined_brown = countDataCombined %>%
  select(-c(OA4, OA5, OA6, OE10, OE11, OE3, OH11, OH15, OH1, OK1, OK2, OK3, ON4, ON5, ON6, OO1, OO2, OP1, OP2, OP3, OQ11, OQ1, OQ4))

# remove the same clone pair (L's) that were removed from other datasets
countDataSym_brown_noclone = countDataSym_brown %>%
  select(-c(OL6_C_B,  OL7_F_B,  OL8_H_B))

countDataCombined_brown_noclone = countDataCombined_brown %>%
  select(-c(OL6_C_B,  OL7_F_B,  OL8_H_B))

# assign treatments for the culture experiment
treatmentCulture = as.factor(sapply(strsplit(colnames(countDataCulture), split = "_"), "[[", 1)) %>%
  revalue(c("Control" = "control", "Cool" = "cold", "Heat" = "heat"))

# assign treatments for the symbionts in hospite
treatmentSym = as.factor(sapply(strsplit(colnames(countDataSym_brown_noclone), split = "_"), "[[", 2)) %>%
  revalue(c("C" = "control", "F" = "cold", "H" = "heat"))

genotypeSym  = as.factor(sapply(strsplit(colnames(countDataSym_brown_noclone), split = ""), "[[", 2))

# create experimental design dataframe for symbiont in culture
expDesign_Culture = data.frame(colnames(countDataCulture), treatmentCulture)
expDesign_Culture$type = "culture"
expDesign_Culture$treat_type = paste(expDesign_Culture$treatmentCulture,expDesign_Culture$type, sep = "_")
names(expDesign_Culture) = c("sample", "treatment", "type", "treat_type")

# create experimental design dataframe for symbiont in hospite
expDesign_Sym = data.frame(colnames(countDataSym_brown_noclone), treatmentSym)
expDesign_Sym$type = "inhost"
expDesign_Sym$treat_type = paste(expDesign_Sym$treatmentSym,expDesign_Sym$type, sep = "_")
names(expDesign_Sym) = c("sample", "treatment", "type", "treat_type")

# combine experimental design data frames into one  
expDesign = rbind(expDesign_Sym, expDesign_Culture) 
expDesign$type = as.factor(expDesign$type)
expDesign$treat_type = as.factor(expDesign$treat_type)
str(expDesign)
```

Experimental Design key with sample names 
```{r,cache=TRUE, echo=FALSE}
kable(expDesign) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```
Descriptive Summary stats of the mapped reads. 

```{r echo=FALSE}
stats.per.sample = data.frame(t(do.call(cbind, lapply(countDataCombined_brown, summary))))
      stats.per.sample$libsum = apply(countDataCombined_brown, 2, sum) ## libsum
      stats.per.sample$perc05 = apply(countDataCombined_brown, 2, quantile, 0.05)
      stats.per.sample$perc10 = apply(countDataCombined_brown, 2, quantile, 0.10)
      stats.per.sample$perc90 = apply(countDataCombined_brown, 2, quantile, 0.90)
      stats.per.sample$perc95 = apply(countDataCombined_brown, 2, quantile, 0.95)
      stats.per.sample$zeros = apply(countDataCombined_brown==0, 2, sum)
      stats.per.sample$percent.zeros = 100*stats.per.sample$zeros/nrow(countDataCombined_brown)
      write.csv(stats.per.sample, file = "/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/sym_culture_inhost_combined_summary_table.csv", quote = FALSE)
      
kable(stats.per.sample) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

### Outlier Detection
Conduct array quality metrics to identify outliers  
Skip while running, but arrayqualitymetrics output can be found on github

```{r, cache=TRUE}
real=newCountDataSet(countDataCombined_brown,expDesign) 
real=estimateSizeFactors(real)
```

```{r, fig.align='center', cache=TRUE}
plot(sort(sizeFactors(real)), main = "Oculina Symbiont Size Factors") 
```
<br>
Size factors of each sample used to normalize between libraries. There is an obvious difference between the high counts of the culture samples (right) and the lower counts of the symbionts in the host (left).
<br> 
<br> 
Create a directory with a bunch of output figures from arrayQualityMetrics() for you to explore if their are outliers. 

```{r message=FALSE, warning=FALSE, eval = FALSE}
cds=DESeq::estimateDispersions(real,method="blind")
vsdBlind=DESeq::varianceStabilizingTransformation(cds)
arrayQualityMetrics(vsdBlind,intgroup="treat_type", force=TRUE, outdir = "/Users/hannahaichelman/Documents/BU/Host_Buffering/CombinedHostSymAnalyses/sym_combined_arrayqualitymetrics") # this makes a directory "arrayQualityMetrics" and outputs various reports on outliers

# detach original DESeq package since we won't need it anymore
detach(package:DESeq, unload = TRUE)
```

Look at total counts across symbiont samples in the host and in culture
```{r, fig.align='center', cache=TRUE}
totalCounts=colSums(countDataCombined_brown)
barplot(totalCounts, col=expDesign$treat_type, ylab="raw counts", main = "Oculina total counts")

min(totalCounts) 
max(totalCounts) 

```
### Outlier Conclusisons

After conducting array quality metrics, the outcome suggests that I do not need to remove outlier samples. However, there is a need to do a batch effect correction, since the symbiont in culture and symbiont in host data were different experiments and sequenced at different times. The best way to do this seems to be using ComBat-Seq:
https://rnabio.org/module-03-expression/0003/05/01/Batch-Correction/
https://github.com/zhangyuqing/ComBat-seq


### Batch Effect Correction

```{r warning=FALSE, cache=TRUE}
# Use ComBat_seq to perform batch correction
# counts is the matrix of gene expression raw counts, converting to a matrix here using as.matrix()
# batch is the batch effect you are worried about (here, whether in culture or in host, because this corresponds to samples being sequenced at different times on different platforms, and with different library prep methods)
# group is the biological treatment of interest(here, temperature treatment)

# ComBat-seq needs raw, unnormalized, unlogged counts as an input. Do not apply any rarification before running the batch effects. 

corrected_data = ComBat_seq(counts = as.matrix(countDataCombined_brown_noclone), batch = expDesign$type, group = expDesign$treatment)
```

Look at total counts across symbiont samples in the host and in culture
```{r, fig.align='center', cache=TRUE}
totalCounts.corr=colSums(corrected_data)
barplot(totalCounts.corr, col=expDesign$treat_type, ylab="raw counts", main = "Oculina total counts - Batch corrected")

min(totalCounts.corr)
max(totalCounts.corr) 
```
There is still a large difference in size factors across the two batches, but we will account for this below.

### Differential Expression of Batch Corrected Data

```{r warning=FALSE, cache=TRUE}
dds.corr<-DESeqDataSetFromMatrix(countData=corrected_data, colData=expDesign, design=~treat_type) #can only test for the main effects of treatment
# pre-filtering to remove low count genes
keep.corr = rowSums(counts(dds.corr) >= 5) >= 40 # at least 40 samples with a count of 5 or higher
dds.corr = dds.corr[keep.corr,]

dds.corr = DESeq2::DESeq(dds.corr)
results.corr = results(dds.corr)
summary(results.corr)

plotDispEsts(dds.corr)
```


Let's check to see if we set up our contrast correctly. We should have the treatment condition first and the control second in the log2 fold change (MLE) output. 

```{r cache=TRUE}
head(results.corr)
summary(results.corr)
```

```{r echo=FALSE, cache=TRUE}
norm.counts.corr = counts(dds.corr, normalized = TRUE) # these are the counts DESeq uses
write.csv(norm.counts.corr,"/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/normalized_counts_symscombined_batchcorr.csv") #these are all counts, not considering treatment comparisons
              
norm.counts.corr.stats = data.frame(
  min = apply(norm.counts.corr, 2, min),
  mean = apply(norm.counts.corr, 2, mean),
  median = apply(norm.counts.corr, 2, median), 
  max = apply(norm.counts.corr, 2, max),
  zeros = apply(norm.counts.corr == 0, 2, sum), 
  percent.zeros = 100* apply(norm.counts.corr == 0, 2, sum) / nrow(norm.counts.corr) 
)

kable(norm.counts.corr.stats) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

norm.counts.corr.sum = colSums(norm.counts.corr)
barplot(norm.counts.corr.sum, col=expDesign$treat_type, ylab="counts", main = "Breviolum psygmophilum Normalized Counts - Batch Corrected")
# blue is freezing, hot pink is hot, and salmon is control for symbionts in host.
# shows that tossing the low count genes and doing the normalization has fixed our size factor issue
```

Now do an rlogged transformation, which is useful for various unsupervised clustering analyses. Be sure the include blind = TRUE as it doesn't normalize the data with any priors from our experimental design. 
Both vst and rlog produce data on the log2 scale which has been normalized with respect to library size or other normalization factors. 

```{r, warning = FALSE, cache=TRUE}
rlogged.corr = rlog(dds.corr, blind = TRUE)
vst.corr = varianceStabilizingTransformation(dds.corr, blind = TRUE)
```

Hot versus control expression comparison in culture
```{r}
##second term is the "control"
res_hot_culture_corr <- results(dds.corr, contrast=c("treat_type","heat_culture","control_culture"))
head(res_hot_culture_corr)
#how many FDR < 10%?
table(res_hot_culture_corr$padj<0.01)
# 0.1=86
# 0.05=71
# 0.01=49
summary(res_hot_culture_corr)
write.table(res_hot_culture_corr, file="/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_hot_symcombined_culture_results.txt", quote=F, sep="\t")
```

MA plot, red dots indicate genes significantly differentially expressed at FDR < 0.1 

```{r, cache=TRUE, fig.align='center'}
DESeq2::plotMA(res_hot_culture_corr, main = "Hot vs Control, In Culture (syms combined), Batch Corrected")
```


Hot versus control expression comparison in the host
```{r}
##second term is the "control"
res_hot_inhost_corr <- results(dds.corr, contrast=c("treat_type","heat_inhost","control_inhost"))
head(res_hot_inhost_corr)
#how many FDR < 10%?
table(res_hot_inhost_corr$padj<0.01)
# 0.1=39
# 0.05=25
# 0.01=12
summary(res_hot_inhost_corr)
write.table(res_hot_inhost_corr, file="/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_hot_symcombined_inhost_results.txt", quote=F, sep="\t")
```

MA plot, red dots indicate genes significantly differentially expressed at FDR < 0.1 

```{r, cache=TRUE, fig.align='center'}
DESeq2::plotMA(res_hot_inhost_corr, main = "Hot vs Control, In Host (syms combined), Batch Corrected")
```

Cold versus control expression comparison in culture
```{r}
##second term is the "control"
res_cold_culture_corr <- results(dds.corr, contrast=c("treat_type","cold_culture","control_culture"))
head(res_cold_culture_corr)
#how many FDR < 10%?
table(res_cold_culture_corr$padj<0.01)
# 0.1=66
# 0.05=49
# 0.01=31
summary(res_cold_culture_corr)
write.table(res_cold_culture_corr, file="/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_cold_symcombined_culture_results.txt", quote=F, sep="\t")
```

MA plot, red dots indicate genes significantly differentially expressed at FDR < 0.1 

```{r, cache=TRUE, fig.align='center'}
DESeq2::plotMA(res_cold_culture_corr, main = "Cold vs Control, In Culture (syms combined), Batch Corrected")
```

Cold versus control expression comparison in host
```{r}
##second term is the "control"
res_cold_inhost_corr <- results(dds.corr, contrast=c("treat_type","cold_inhost","control_inhost"))
head(res_cold_inhost_corr)
#how many FDR < 10%?
table(res_cold_inhost_corr$padj<0.01)
# 0.1=2
# 0.05=1
# 0.01=1
summary(res_cold_inhost_corr)
write.table(res_cold_inhost_corr, file="/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_cold_symcombined_inhost_results.txt", quote=F, sep="\t")
```

MA plot, red dots indicate genes significantly differentially expressed at FDR < 0.1 

```{r, cache=TRUE, fig.align='center'}
DESeq2::plotMA(res_cold_inhost_corr, main = "Freezing vs Control, In Host (syms combined), Batch Corrected")
```

Plot row standard deviations vs. row means to compare rlog and vst transformations.
Looking for a horizontal red line, which indicates that there is no variance-mean dependence.
```{r echo=FALSE, fig.align = 'center'}
library(vsn)
meanSdPlot(as.matrix(assay(rlogged.corr)))
meanSdPlot(as.matrix(assay(vst.corr)))
```

Moving forward with batch corrected (using ComBat-seq) and rlog-transformed data. 


## Make a barplot of differentially expressed genes
```{r, cache=TRUE, fig.align='center'}
summary(res_hot_culture_corr)
# up = 37
# down = 49
summary(res_hot_inhost_corr)
# up = 14
# down = 25
summary(res_cold_culture_corr)
# up = 33
# down = 33
summary(res_cold_inhost_corr)
# up = 2
# down = 0

sym_combined_degs = data.frame(
  temperature = factor(c("Heat", "Heat", "Heat", "Heat", "Cold", "Cold", "Cold", "Cold")),
  type = factor(c("Sym_InCulture", "Sym_InCulture","Sym_InHost", "Sym_InHost", "Sym_InCulture", "Sym_InCulture","Sym_InHost", "Sym_InHost")),
  direction = factor(c("up","down","up","down","up","down","up","down")),
  temperature_direction = factor(c("heat_up","heat_down", "heat_up","heat_down", "cold_up","cold_down","cold_up","cold_down")),
  number = c(37, -49, 14, -25, 33, -33, 2, 0)
)

annotate_text = data.frame(
  label = c("33", "33", "1", "0","37", "49","14", "25"),
  temperature = factor(c("Heat", "Heat", "Heat", "Heat", "Cold", "Cold", "Cold", "Cold")),
  type = factor(c("Sym_InCulture", "Sym_InCulture","Sym_InHost", "Sym_InHost", "Sym_InCulture", "Sym_InCulture","Sym_InHost", "Sym_InHost")),
  direction = factor(c("up","down","up","down","up","down","up","down")),
  temperature_direction = factor(c("heat_up","heat_down", "heat_up","heat_down", "cold_up","cold_down","cold_up","cold_down")),
  x = c(1,1,1,1,2,2,2,2),
  y = c(38,-38,5,-5,40,-53,18,-30)
)

cols = c("cold_up" = "#74c476", "cold_down" =  "#c7e9c0","heat_up" = "#fd8d3c", "heat_down" ="#fdd0a2")

deg_barplot = ggplot(sym_combined_degs, aes(x = temperature, y = number, fill=temperature_direction)) +
  geom_bar(stat = "identity", position = position_stack(), color = "black") +
  scale_fill_manual(values = cols) +
  xlab("Temperature Treatment") +
  ylab("Differentially expressed genes") +
  theme_bw() +
  theme(legend.position = "none") +
  facet_grid(. ~ type) +
  theme(panel.spacing = unit(0, "lines")) +
  geom_text(data = annotate_text, aes(x = x, y = y, label = label))
deg_barplot

ggsave(deg_barplot, file = "/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/plots/symcombined_deg_barplot.pdf", width=5, height=4, units=c("in"), useDingbats=FALSE)
```

Moving forward with batch corrected (using ComBat-seq) and rlog-transformed data. 
This decision followed conversations with Mike Love about the benefits of rlog for this dataset.

### Principal Component Analyses - Batch Corrected

<br>
First we create a PCA data frame and calculate the variance estimated by PC1 and PC2
```{r cache=TRUE, fig.align="center"}
pcadata.corr.rlog = DESeq2::plotPCA(rlogged.corr, intgroup = "treat_type", returnData = TRUE)
percentVar.corr.rlog = round(100 * attr(pcadata.corr.rlog, "percentVar"))
pca.corr.rlog = prcomp(t(assay(rlogged.corr)), center = TRUE, scale. = FALSE)
```
<br><br>

Using adonis from library(vegan) we can see if there are any significant differences based on treatment (as is illustrated in the model displayed below) 
```{r cache=TRUE}
adonis2(pca.corr.rlog$x ~ treat_type, data = pcadata.corr.rlog, method = 'eu', na.rm = TRUE)
#            Df SumOfSqs      R2      F Pr(>F)    
# treat_type  5   202.33 0.32977 3.7393  0.001 ***
# Residual   38   411.22 0.67023                  
# Total      43   613.54 1.00000                  

```
<br><br>
Significant effect of treatment_type combo factor (p = 0.001)

Principal component analyses highlighting treatment groups. Treatment has a significant affect (p < 0.001) on overall expression

<br><br>

```{r cache=TRUE, fig.align="center"}
cols_sym = c("control" = "#a6611a", "cold" = "#74c476", "heat" = "#fd8d3c")

# takes top 500 genes (different from prcomp)

plotPCA_rlog_batchcorr = DESeq2::plotPCA(rlogged.corr, returnData = TRUE, intgroup = c("treatment", "type","treat_type")) %>% 
      ggplot(aes(x = PC1, y = PC2)) +
      geom_point(aes(colour = treatment, shape = type), size = 3) +
      stat_ellipse(aes(x = PC1, y = PC2, color=treatment, group=treat_type, lty = type), 
                   type = "t", 
                   lwd = 1)+    
      scale_color_manual(values = cols_sym,
                         name = "Treatment") +
      scale_shape_manual(values = c(21,19),
                         name = "Location",
                         labels = c("in culture","in host"))+
      
      scale_linetype_manual(values = c(2,1,2,1,2,1),
                           name = "Location",
                           labels = c("in culture","in host")) +
      xlab(paste0("PC1: ",percentVar.corr.rlog[1],"% variance")) +
      ylab(paste0("PC2: ",percentVar.corr.rlog[2],"% variance")) +
      #labs(title = "rlog, batch corr, plotPCA")+
      theme_bw() 
plotPCA_rlog_batchcorr

ggsave(plotPCA_rlog_batchcorr, filename = "/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/plots/symcombined_pca.pdf", width=5, height=4, units=c("in"), useDingbats=FALSE)

```

Plot the same PCA but using prcomp, which uses all genes, instead of DESeq's built-in package.
Rlogged data:
```{r, cache = TRUE}
# pca.corr.rlog from above code
# pca.corr.rlog = prcomp(t(assay(rlogged.corr)), center = TRUE, scale. = FALSE)

li.corr.rlog <- pca.corr.rlog$sdev^2 / sum(pca.corr.rlog$sdev^2)
pc1v.corr.rlog <- round(li.corr.rlog[1] * 100, 1)
pc2v.corr.rlog <- round(li.corr.rlog[2] * 100, 1)
pca_s.corr.rlog <- as.data.frame(pca.corr.rlog$x)

pca_s.corr.rlog <- pca_s.corr.rlog[,c(1,2)]
pca_s.corr.rlog$Samples = row.names(pca_s.corr.rlog)
pca_s.corr.rlog$treat_type = expDesign$treat_type
pca_s.corr.rlog$type = expDesign$type


prcomp_rlog_batchcorr = ggplot(pca_s.corr.rlog, aes(PC1, PC2, color = treat_type, pch = type)) +
  geom_point(aes(colour = treat_type, shape = type), size = 3) +
  scale_color_manual(values = cols) +
  stat_ellipse(geom = "polygon", alpha = 0.4, aes(fill = treat_type)) +
  scale_fill_manual(values = cols) +
  #geom_polygon(alpha=.2) +
  xlab(paste0("PC1: ",pc1v.corr.rlog,"% variance")) +
  ylab(paste0("PC2: ",pc2v.corr.rlog,"% variance")) +
  labs(title = "rlog, batch corr, prcomp")+
  theme_cowplot() +
  theme(legend.position = "none")

prcomp_rlog_batchcorr
```




### Transformation Info
According to Mike Love:
I prefer VST when there are many samples. The rlog seemed to outperform
(according to our simulations performed in the DESeq2 paper) when there
were very large differences in size factor (e.g. spanning an order of
magnitude from low to high seq depth). (https://support.bioconductor.org/p/98473/)

The above info seems to suggest that it would be most appropriate to use rlog here, since we have large differences in size factors.


This is corroborated here: https://compbiocore.github.io/deseq-workshop-1/assets/deseq_workshop_1.html

Which transformation to choose? The rlog tends to work well on small datasets (n < 30), sometimes outperforming the VST when there is a large range of sequencing depth across samples (an order of magnitude difference). The VST is much faster to compute and is less sensitive to high count outliers than the rlog. We therefore recommend the VST for large datasets (hundreds of samples). You can perform both transformations and compare the meanSdPlot or PCA plots generated, as described below.

### PCA Plasticity 

PCA plasticity functions written by C. Bove.

This function allows you to save all principal components 
```{r}
plotPCA_allPCs <- function (object, intgroup = "condition", ntop = 500, returnData = FALSE)
{
  rv <- rowVars(assay(object)) # Variance estimates for each row (column) in a matrix.
  select <- order(rv, decreasing = TRUE)[seq_len(min(ntop, length(rv)))] # orders genes from largest -> smallest and pulls ntop (default 500) genes
  pca <- prcomp(t(assay(object)[select, ]), center = TRUE, scale. = FALSE) # performs PCA on ntop (default 500) from dataset
  percentVar <- pca$sdev^2/sum(pca$sdev^2)
  if (!all(intgroup %in% names(colData(object)))) {
    stop("the argument 'intgroup' should specify columns of colData(dds)")
  }
  intgroup.df <- as.data.frame(colData(object)[, intgroup, drop = FALSE])
  group <- if (length(intgroup) > 1) {
    factor(apply(intgroup.df, 1, paste, collapse = ":"))
  }
  else {
    colData(object)[[intgroup]]
  }
  d <- data.frame(group = group, intgroup.df, name = colnames(object), pca$x)
  if (returnData) {
    attr(d, "percentVar") <- percentVar[1:2]
    return(d)
  }
  ggplot(data = d, aes_string(x = "PC1", y = "PC2", color = "group")) +
    geom_point(size = 3) + xlab(paste0("PC1: ", round(percentVar[1] *
                                                        100), "% variance")) + ylab(paste0("PC2: ", round(percentVar[2] *
                                                                                                            100), "% variance")) + coord_fixed()
}
```

```{r eval=FALSE, include=FALSE}
# source the script Colleen wrote with the different functions to calculate plasticity
source("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/GE_Plasticity/PlasticityCustomFunctions_means.R")

# use modified plotPCA function to give you all PCs
pcadata.plast = plotPCA_allPCs(rlogged.corr, intgroup = c("treat_type", "type"), returnData = TRUE)

pcadata.inhost.plast = pcadata.plast %>%
  filter(type == "inhost")

pcadata.culture.plast = pcadata.plast %>%
  filter(type == "culture")


pca_plast_host <-  PCAplast(pca = pcadata.inhost.plast[,c(5:ncol(pcadata.inhost.plast))], # PCA dataframe containing the PCA eigenvalues
                data = pcadata.inhost.plast[,c(1:4)], # condition/treatment data 
                sample_ID = "name", # name of column with unique ID per sample (if blank, will pull rownames for this)
                num_pca = "2", # number of PCs to include in measure (default is 'all' if left blank)
                control_col = "treat_type", # name of 'treatment' column
                control_lvl = "control_inhost") # control level of the treatment 

pca_plast_culture <-  PCAplast(pca = pcadata.culture.plast[,c(5:ncol(pcadata.culture.plast))], # PCA dataframe containing the PCA eigenvalues
                data = pcadata.culture.plast[,c(1:4)], # condition/treatment data 
                sample_ID = "name", # name of column with unique ID per sample (if blank, will pull rownames for this)
                num_pca = "2", # number of PCs to include in measure (default is 'all' if left blank)
                control_col = "treat_type", # name of 'treatment' column
                control_lvl = "control_culture") # control level of the treatment 

```
Now plot PCA plasticity, separately for host and symbiont
```{r}
library(Rmisc)
all_plast = rbind(pca_plast_host, pca_plast_culture) # re-combine host and symbiont plasticity for plotting

dist_summ = summarySE(data = all_plast, measurevar = "dist", groupvars = c("treat_type","type"))

lm = lm(dist ~ treat_type, data = all_plast)
summary(lm)
# Coefficients:
#                           Estimate Std. Error t value Pr(>|t|)    
# (Intercept)                 2.3125     0.2228  10.380 3.16e-12 ***
# treat_typecold_inhost      -1.7002     0.2793  -6.088 5.91e-07 ***
# treat_typecontrol_culture  -1.1850     0.2728  -4.343 0.000114 ***
# treat_typecontrol_inhost   -1.8513     0.2793  -6.629 1.16e-07 ***
# treat_typeheat_culture      0.3500     0.2728   1.283 0.208032    
# treat_typeheat_inhost      -0.6721     0.2793  -2.407 0.021517 *  

aov = aov(dist ~ treat_type, data = all_plast)
summary(aov)
#             Df Sum Sq Mean Sq F value   Pr(>F)    
# treat_type   5 27.560   5.512   27.77 2.93e-11 ***
# Residuals   35  6.948   0.199                     

TukeyHSD(aov)
# $treat_type
#                                      diff        lwr        upr     p adj
# cold_inhost-cold_culture       -1.7002207 -2.5417221 -0.8587193 0.0000084
# control_culture-cold_culture   -1.1850361 -2.0071900 -0.3628821 0.0014851
# control_inhost-cold_culture    -1.8513168 -2.6928182 -1.0098155 0.0000017
# heat_culture-cold_culture       0.3499743 -0.4721797  1.1721282 0.7922376
# heat_inhost-cold_culture       -0.6720720 -1.5135734  0.1694294 0.1817619
# control_culture-cold_inhost     0.5151846 -0.1796623  1.2100315 0.2484358
# control_inhost-cold_inhost     -0.1510962 -0.8687309  0.5665386 0.9875687
# heat_culture-cold_inhost        2.0501949  1.3553481  2.7450418 0.0000000
# heat_inhost-cold_inhost         1.0281487  0.3105139  1.7457835 0.0016006
# control_inhost-control_culture -0.6662808 -1.3611277  0.0285661 0.0664774
# heat_culture-control_culture    1.5350103  0.8637244  2.2062962 0.0000008
# heat_inhost-control_culture     0.5129641 -0.1818828  1.2078109 0.2526038
# heat_culture-control_inhost     2.2012911  1.5064442  2.8961380 0.0000000
# heat_inhost-control_inhost      1.1792448  0.4616101  1.8968796 0.0002518
# heat_inhost-heat_culture       -1.0220463 -1.7168932 -0.3271994 0.0011503

cols_sym = c("#a6611a","#a6611a", "#74c476","#74c476", "#fd8d3c", "#fd8d3c")

# symbiont in host GE plasticity plot
plast_plot = ggplot(dist_summ, aes(x = treat_type, y = dist)) +
      geom_point(aes(colour = treat_type, shape = type), size = 4) +
      geom_errorbar(aes(x = treat_type, ymin = dist - sd, ymax = dist + sd, colour = treat_type), width = 0.2) +
      scale_color_manual(values = cols_sym) +
      scale_fill_manual(values = cols_sym) +
      xlab("Treatment") +
      ylab("Plasticity") +
      labs(title = "Gene Expression Plasticity") +
      theme_cowplot() +
      theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1), legend.position = "none")
plast_plot

ggsave(plast_plot, filename = "/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/plots/PCA_plasticity_2PCs_symcombined.pdf", width=6, height=5, units=c("in"), useDingbats=FALSE)

# boxplot with points overlaid
all_plast_nocontrol = all_plast %>%
  dplyr::filter(treat_type != "control_inhost") %>%
  dplyr::filter(treat_type != "control_culture")

cols_nocontrol = c("#74c476","#74c476", "#fd8d3c", "#fd8d3c")

plast_boxplot <- ggplot(all_plast_nocontrol, aes(x = treat_type, y = dist)) +
  geom_boxplot(outlier.shape = NA,
               alpha = 0.8,
               aes(fill = treat_type))+
  scale_fill_manual(values = cols_nocontrol) + # for boxplot
  geom_jitter(size = 2,
              position=position_jitter(0.2), 
              alpha=0.99,
              aes(shape = type),
              color = 'black') +
  scale_shape_manual(values = c(21,19)) +
  scale_color_manual(values = cols_nocontrol) + # for jittered points
  ylab("Gene Expression Plasticity") +
  #xlab("Site") +
  #theme(axis.text.x = element_text(angle = 45, vjust=0.7, hjust=.6)) +
  theme_bw() +
  #theme(legend.position = "none") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, face ="bold"), legend.position = "none") +
  theme(axis.title.x = element_blank())
plast_boxplot

ggsave(plast_boxplot, filename = "/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/plots/PCA_plasticity_boxplot_symcombined.pdf", width=3, height=4, units=c("in"), useDingbats=FALSE)

```

### Gene Ontology
Make Gene Ontology input table for MWU for hot treatment
```{r message=FALSE, warning=FALSE, eval = FALSE}
oc_hot_culture_res = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_hot_symcombined_culture_results.txt")
head(oc_hot_culture_res)
oc_hot_culture_res$isogroup=row.names(oc_hot_culture_res)

go_input_hot_culture = oc_hot_culture_res %>%
  mutate(mutated_p = -log(pvalue)) %>%
  mutate(mutated_p_updown = ifelse(log2FoldChange < 0, mutated_p*-1, mutated_p*1)) %>%
  select(isogroup, mutated_p_updown) %>%
  na.omit()

nrow(go_input_hot_culture)
head(go_input_hot_culture)
colnames(go_input_hot_culture) <- c("gene", "pval")
head(go_input_hot_culture)
write.csv(go_input_hot_culture, file="/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/Oculina_GO_Analyses/oculina_hot_symcombined_culture_GO.csv", quote=F, row.names=FALSE)

oc_hot_inhost_res = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_hot_symcombined_inhost_results.txt")
head(oc_hot_inhost_res)
oc_hot_inhost_res$isogroup=row.names(oc_hot_inhost_res)

go_input_hot_inhost = oc_hot_inhost_res %>%
  mutate(mutated_p = -log(pvalue)) %>%
  mutate(mutated_p_updown = ifelse(log2FoldChange < 0, mutated_p*-1, mutated_p*1)) %>%
  select(isogroup, mutated_p_updown) %>%
  na.omit()

nrow(go_input_hot_inhost)
head(go_input_hot_inhost)
colnames(go_input_hot_inhost) <- c("gene", "pval")
head(go_input_hot_inhost)
write.csv(go_input_hot_inhost, file="/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/Oculina_GO_Analyses/oculina_hot_symcombined_inhost_GO.csv", quote=F, row.names=FALSE)

```

Make Gene Ontology input table for MWU for Oculina cold treatment
```{r message=FALSE, warning=FALSE, eval = FALSE}
oc_cold_culture_res = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_cold_symcombined_culture_results.txt")
head(oc_cold_culture_res)
oc_cold_culture_res$isogroup=row.names(oc_cold_culture_res)

go_input_cold_culture = oc_cold_culture_res %>%
  mutate(mutated_p = -log(pvalue)) %>%
  mutate(mutated_p_updown = ifelse(log2FoldChange < 0, mutated_p*-1, mutated_p*1)) %>%
  select(isogroup, mutated_p_updown) %>%
  na.omit()

nrow(go_input_cold_culture) #200
head(go_input_cold_culture)
colnames(go_input_cold_culture) <- c("gene", "pval")
head(go_input_cold_culture)
write.csv(go_input_cold_culture, file="/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/Oculina_GO_Analyses/oculina_cold_symcombined_culture_GO.csv", quote=F, row.names=FALSE)

oc_cold_inhost_res = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_cold_symcombined_inhost_results.txt")
head(oc_cold_inhost_res)
oc_cold_inhost_res$isogroup=row.names(oc_cold_inhost_res)

go_input_cold_inhost = oc_cold_inhost_res %>%
  mutate(mutated_p = -log(pvalue)) %>%
  mutate(mutated_p_updown = ifelse(log2FoldChange < 0, mutated_p*-1, mutated_p*1)) %>%
  select(isogroup, mutated_p_updown) %>%
  na.omit()

nrow(go_input_cold_inhost)
head(go_input_cold_inhost)
colnames(go_input_cold_inhost) <- c("gene", "pval")
head(go_input_cold_inhost)
write.csv(go_input_cold_inhost, file="/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/Oculina_GO_Analyses/oculina_cold_symcombined_inhost_GO.csv", quote=F, row.names=FALSE)
```

### Heatmaps
***
<br> <br> 

Overall expression, sample by distance. 

```{r fig.align="center", cache=TRUE}
sampleDists <- as.matrix(dist(t(assay(rlogged.corr))))
heatmap.2(as.matrix(sampleDists), key=F, trace="none",
          col=colorpanel(100, "black", "white"),
          margin=c(10, 10))
```

<br><br>
<b>Individual genes heatmap </b> 
<br> 
Now plotting the z scores, as heatmap2 creates nice clean clusters by doing this. Upregulation indicated by warmer colors, downregulation indicated by cooler colors.

First for heat vs. control comparison in culture
```{r, cache=TRUE, fig.align='center'}
norm_counts = read.csv("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/normalized_counts_symscombined_batchcorr.csv") 

hm = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_hot_symcombined_culture_results.txt", header=TRUE) %>%
  rownames_to_column("X") %>%
  filter(padj < 0.1) %>% # only want the most DEGs
  select(X) %>%
  merge(norm_counts, by.x = "X", by.y = "X") %>% # turn into a countdatafile
  column_to_rownames(var = "X")

## Turning into z-score table
hm.z = data.matrix(hm)
hm.z = sweep(hm.z, 1L, rowMeans(hm.z), check.margin = FALSE)
hm.z.sx = apply(hm.z, 1L, sd)
hm.z = sweep(hm.z, 1L, hm.z.sx, "/", check.margin = FALSE)
hm.z = data.matrix(hm.z)

colour = colorRampPalette(rev(c("chocolate1","#FEE090","grey10", "cyan3","cyan")))(100)
heatmap.2(hm.z, col = colour, Rowv = TRUE, Colv = TRUE, scale = "row", 
          dendrogram = "both",
          trace = "none", 
          margin = c(5,15))
```

Now for cold vs. control comparison in culture
```{r, cache=TRUE, fig.align='center'}
norm_counts = read.csv("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/normalized_counts_symscombined_batchcorr.csv") 

hm = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_cold_symcombined_culture_results.txt", header=TRUE) %>%
  rownames_to_column("X") %>%
  filter(padj < 0.1) %>% # only want the most DEGs
  select(X) %>%
  merge(norm_counts, by.x = "X", by.y = "X") %>% # turn into a countdatafile
  column_to_rownames(var = "X")

## Turning into z-score table
hm.z = data.matrix(hm)
hm.z = sweep(hm.z, 1L, rowMeans(hm.z), check.margin = FALSE)
hm.z.sx = apply(hm.z, 1L, sd)
hm.z = sweep(hm.z, 1L, hm.z.sx, "/", check.margin = FALSE)
hm.z = data.matrix(hm.z)

colour = colorRampPalette(rev(c("chocolate1","#FEE090","grey10", "cyan3","cyan")))(100)
heatmap.2(hm.z, col = colour, Rowv = TRUE, Colv = TRUE, scale = "row", 
          dendrogram = "both",
          trace = "none", 
          margin = c(5,15))
```

Could repeat for in host heatmaps but skipping for now

### Log2 Fold Change Density Plots

```{r}
culture_cold_res = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_cold_symcombined_culture_results.txt", header=TRUE) %>%
  mutate(type = "culture_cold")
culture_hot_res = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_hot_symcombined_culture_results.txt", header=TRUE) %>%
  mutate(type = "culture_hot")
host_cold_res = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_cold_symcombined_inhost_results.txt", header=TRUE) %>%
  mutate(type = "host_cold")
host_hot_res= read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_hot_symcombined_inhost_results.txt", header=TRUE) %>%
  mutate(type = "host_hot")

# all types combined
res_combined = rbind(culture_cold_res, culture_hot_res, host_cold_res, host_hot_res) %>%
  mutate(abs_log2foldchange = abs(log2FoldChange))
res_combined$type = as.factor(res_combined$type)

res_cols = c("#2166ac", "#b2182b", "#67a9cf", "#ef8a62")

# plot the absolute value of log 2 fold change as a density plot, color by group
ggplot(res_combined, aes(x = abs(log2FoldChange), group = type, color = type))+
  geom_density(lwd = 1.5) +
  scale_color_manual(values = res_cols) +
  xlab("|log-fold change relative to control|") +
  theme_cowplot()

# hot treatments separate
res_combined_hot = rbind(culture_hot_res, host_hot_res)
res_combined_hot$type = as.factor(res_combined_hot$type)

res_cols_hot = c("#b2182b", "#ef8a62")

ggplot(res_combined_hot, aes(x = abs(log2FoldChange), group = type, color = type))+
  geom_density(lwd = 1.5) +
  scale_color_manual(values = res_cols_hot) +
  xlab("|log-fold change relative to control|") +
  theme_cowplot()

# cold treatments separate
res_combined_cold = rbind(culture_cold_res, host_cold_res)
res_combined_cold$type = as.factor(res_combined_cold$type)

res_cols_cold = c("#2166ac", "#67a9cf")

ggplot(res_combined_cold, aes(x = abs(log2FoldChange), group = type, color = type))+
  geom_density(lwd = 1.5) +
  scale_color_manual(values = res_cols_cold) +
  xlab("|log-fold change relative to control|") +
  theme_cowplot()

# do stats on the absolute value of log2fold change
summarySE(res_combined)

aov1 = aov(abs_log2foldchange~type, data=res_combined)
summary(aov1)
TukeyHSD(aov1)

lm1 = lm(abs_log2foldchange~type, data=res_combined)
summary(lm1)
```

### Log2 Fold Change Correlation Plots

```{r}
library(plotly)

# make lfc combined matrix to plot lfc in host vs. in culture
# start with heat datasets first

culture_hot_res_merge = culture_hot_res %>%
  select(log2FoldChange) %>%
  rownames_to_column(var = "gene")

host_hot_res_merge = host_hot_res %>%
  select(log2FoldChange) %>%
  rownames_to_column(var = "gene")

hot_res_merged = left_join(culture_hot_res_merge, host_hot_res_merge, by = "gene")

# combine in host and in culture df's for lfc
hot_res_merged = hot_res_merged %>%
  dplyr::rename(log2FoldChange.inculture = log2FoldChange.x) %>%
  dplyr::rename(log2FoldChange.inhost = log2FoldChange.y)

# add gene name to this df - trim down names and add to photo_genes
iso2gene = read.delim("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_TagSeq/References/B_psygmophilum_transcriptome/B_psygmophilum_isogroup_to_genename.tab", sep = "\t", header = FALSE) %>%
  dplyr::rename("gene" = "V1") %>%
  dplyr::rename("gene_name" = "V2")

iso2gene$gene_name = gsub("OS=.*", "", iso2gene$gene_name)
head(iso2gene)

# combine with lfc merged dataframe
hot_res_merged_anno = hot_res_merged %>%
  left_join(iso2gene, by = "gene")
head(hot_res_merged_anno)

# look for most correlated categories
# can id delta ranks using this plotly:
heat_plotly = ggplot(hot_res_merged_anno, aes(x = log2FoldChange.inculture, y = log2FoldChange.inhost)) +
  geom_point(aes(text = paste("Gene:", gene_name)), size = 2) +
  geom_hline(yintercept = 0, lty = 2) +
  geom_vline(xintercept = 0, lty = 2) +
  ggtitle("Heat Challenge")
ggplotly(heat_plotly)


# now repeat with cold challenge data

culture_cold_res_merge = culture_cold_res %>%
  select(log2FoldChange) %>%
  rownames_to_column(var = "gene")

host_cold_res_merge = host_cold_res %>%
  select(log2FoldChange) %>%
  rownames_to_column(var = "gene")

cold_res_merged = left_join(culture_cold_res_merge, host_cold_res_merge, by = "gene")

# combine in host and in culture df's for lfc
cold_res_merged = cold_res_merged %>%
  dplyr::rename(log2FoldChange.inculture = log2FoldChange.x) %>%
  dplyr::rename(log2FoldChange.inhost = log2FoldChange.y)

# add gene name to this df - trim down names and add to photo_genes
# combine with lfc merged dataframe
cold_res_merged_anno = cold_res_merged %>%
  left_join(iso2gene, by = "gene")
head(cold_res_merged_anno)

# look for most correlated categories
# can id delta ranks using this plotly:
cold_plotly = ggplot(cold_res_merged_anno, aes(x = log2FoldChange.inculture, y = log2FoldChange.inhost)) +
  geom_point(aes(text = paste("Gene:", gene_name)), size = 2) +
  geom_hline(yintercept = 0, lty = 2) +
  geom_vline(xintercept = 0, lty = 2) +
  ggtitle("Cold Challenge")
ggplotly(cold_plotly)

```


### Venn Diagrams

Read in our result tables and isolate gene lists that are significant in each experiment. 

```{r eval=FALSE, cache=TRUE, include=FALSE}
culture_hot = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_hot_symcombined_culture_results.txt", header = TRUE)
culture_hot = row.names(culture_hot[culture_hot$padj<0.05 & !is.na(culture_hot$padj),])

culture_cold = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_cold_symcombined_culture_results.txt", header = TRUE)
culture_cold = row.names(culture_cold[culture_cold$padj<0.05 & !is.na(culture_cold$padj),])

inhost_hot = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_hot_symcombined_inhost_results.txt", header = TRUE)
inhost_hot = row.names(inhost_hot[inhost_hot$padj<0.05 & !is.na(inhost_hot$padj),])

inhost_cold = read.table("/Users/hannahaichelman/Documents/BU/Host_Buffering/MPCC_2018/Sym_analyses/tables/oculina_cold_symcombined_inhost_results.txt", header = TRUE)
inhost_cold = row.names(inhost_cold[inhost_cold$padj<0.05 & !is.na(inhost_cold$padj),])

```
<br><br>

Set up a venn diagram looking for similar genes in each experiment. 
```{r eval=FALSE, cache=TRUE, include=FALSE}
all_shared.culture = list("Heat" = culture_hot, "Cold" = culture_cold)
prettyvenn.culture=venn.diagram(
      x = all_shared.culture,
      filename=NULL,
      col = "transparent",
      fill = c("#fd8d3c", "#74c476"),
      alpha = 0.5,
      #label.col = c("darkred", "white", "darkgreen", "white", "white", "white", "blue4"),
      cex = 2.5,
      fontfamily = "sans",
      fontface = "bold",
      cat.default.pos = "text",
      cat.col = "black",
      cat.cex = 2.5,
      cat.fontfamily = "sans",
      cat.dist = c(0.08, 0.08),
      cat.pos = 1
    );
grid.draw(prettyvenn.culture)
    
all_shared.inhost = list("Heat" = inhost_hot, "Cold" = inhost_cold)
prettyvenn.inhost=venn.diagram(
      x = all_shared.inhost,
      filename=NULL,
      col = "transparent",
      fill = c("#fd8d3c", "#74c476"),
      # label.col = c("darkred", "white", "darkgreen", "white", "white", "white", "blue4"),
      cex = 2.5,
      fontfamily = "sans",
      fontface = "bold",
      cat.default.pos = "text",
      cat.col = "black",
      cat.cex = 2.5,
      cat.fontfamily = "sans",
      cat.dist = c(0.08, 0.08),
      cat.pos = 1
    );
grid.draw(prettyvenn.inhost)
```




### DAPC
Looks like I want to run the DAPC with 3ish PC (if that many) just a heads up.  
If you just run: dapc(ge_matrix, grp_pca$symb_reef)
then it will prompt you to select your number of PCs (from a plot) and you can type the number there. Then it will do the same for DAs
You may use more, but just make sure when you run it first, you donâ€™t specify the PC or DA numbers like it did. But you can specify them once you select!

```{r eval=FALSE, include=FALSE}

## convert vsd to matrix
rlog.corr.ge.matrix <- t(assay(rlogged.corr)) 

## grouping variable:
grp_pca <- DESeq2::plotPCA(rlogged.corr, intgroup = c("treat_type", "type"), returnData = TRUE)

## 
dapc1 = dapc(rlog.corr.ge.matrix, grp_pca$treat_type)
scatter(dapc1)
scatter(dapc1,1,1)

find.clusters(rlog.corr.ge.matrix, max.n.clust=40)

## Run the treatment and type DAPC with 43 PCs and 6 DAs
dapc2 <- dapc(rlog.corr.ge.matrix, grp_pca$treat_type, n.pca = 3, n.da = 6)
dapc2
summary(dapc2)
scatter(dapc2)

scatter(dapc2,1,1, cols = cols, bg = "white", scree.da = FALSE, legend = TRUE, solid = 0.6)
```